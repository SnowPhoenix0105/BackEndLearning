# Docker学习笔记（二）

暑期加入了沃天宇老师的实验室进行暑期的实习。在正式开始工作之前，师兄先让我了解一下技术栈，需要了解的有docker、k8s、springboot、springcloud。

仅以一系列博客记录一下自己学习的笔记。更多内容见[Github](https://github.com/SnowPhoenix0105/BackEndLearning)


2021/7/6



## 容器的文件系统

容器间的文件是相互隔离的，即使它们都使用同一个镜像。

### 实验

```powershell
docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
```

* `-d`选项表示detached模式，这个前面已经了解了；
* `ubuntu`应当是指定使用的镜像，因为输入指令之后我们就可以看到docker从中央仓库pull下来了ubuntu的镜像；
* `bash`我猜测是指定了运行的程序，bash体验确实优于sh；
* `-c` 后面指定了一个运行的命令，我猜测`c`是`command`的缩写，而后面的语句的意思应该是向`/data.txt`写入一个1~10000的随机数，然后不断向控制台输出`/dev/null`中新加入的内容；

通过`docker ps`拿到刚刚启动的容器的id后，我们通过以下指令可以拿到`/data.txt`中的随机数：

```powershell
docker exec <CONTAINER> cat /data.txt
```

之后，我们再启动一个镜像：

```powershell
docker run -it ubuntu ls /
```

* `-it`应当是一个区别于`-d`的选项，我们看到这条语句运行完成之后直接在console显示了结果；
* `ls /`应当是要在这个容器内执行的程序，因为我们可以看到这个语句完成之后打印了一个目录的列表；

这里我们也能看到在上一个run指令中，`-c`其实是传给`bash`的参数，而不是`docker run`的参数。

从这里的结果可以看出，新创建的镜像中没有第一个镜像中的`/data.txt`，这就证明了这两个使用相同镜像的容器中的文件系统是相互隔离的，它们互相无法访问到彼此的文件。

#### 实验后的小探究

实验结束后，使用`docker ps`指令可以发现，第一个启动的容器并没有停止，而第二个容器已经停止了，通过`docker ps -a`可以看到被停止的容器。

仔细观察两次启动容器的区别，可以发现，第一个容器中，特地使用了`tail -f`，这个指令会进入一个有死循环的程序，只要不主动退出，就不会完成，而第二个容器中使用的是`ls`，当打印完目录的内容后，就结束了，此时容器就停止了。

为了探究`-it`的作用，先通过`docker run --help`得知，`-i`的作用是保持`stdin`为开启状态，即使没有attached，而`-t`是打开一个虚拟终端，二者通常一起使用。

直接运行

```powershell
docker run -it ubuntu
docker run -it ubuntu bash
```

二者似乎会产生相同的效果，我们可以看到如下效果：

<img src="./images/docker-it-ubuntu-bash.png" style="zoom: 40%">

我们进入了一个终端，并且打开另一个Powershell终端输入`docker ps`，可以发现这个容器并没有停止，而是处于运行的状态，并且这个bash前面`root@xxxxxx`中的`xxxxx`就是这个容器的ID。

此外，我们还可以发现，就算启动时，我们没有指定`bash`这个参数，`docker ps`中的`COMMAND`一列，还是会显示为`bash`，看来bash很可能是一个默认的行为，猜测可能跟ubuntu镜像的Dockerfile相关。

我还对`docker exec`指令试验了`-it`的效果：

```powershell
docker exec -it <CONTAINER> bash
```

这里的`bash`就不能省略了，否则会报错。我输入了第一个容器的id，通过`cat /data.txt`仍旧可以拿出之前获得的那个随机数。而如果输入了一个已经停止的容器的id，就会报错，exec指令只能用于访问一个正在运行的指令，而不能访问一个已经停止的容器。

从上述的探究来看，一个容器如果其指令全部执行完毕，就会停止，此时无法在通过`docker exec`来进入容器进行操作；倘若我们想要通过`docker exec -it`进入容器操作，我们就需要让容器进入一个不会退出的程序来*保活*。不过可能有一些指令能够让一个已经停止的容器恢复运行。

实验结束之后，我们需要清理一下这些容器：

```powershell
docker rm -f $(docker ps -aq)
```

这个是搜索来的指令，其中`docker rm -f`我们已经熟悉了，它表示删除一个容器，如果容器正在运行，就会停止并删除，而后面的部分`docker ps -aq`中，`-q`的作用是只保留id，这样它的结果就是一串`CONTAINER_ID`，作为`docker rm -f`的参数。





